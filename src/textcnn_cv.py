import os
import numpy as np
import torch
import torch.nn as nn
import argparse
from tqdm import tqdm
from model.Malware_Textcnn import Malware_tcnn_classifier
from utils.dataloader_seq import ExeDataset
from utils.dataloader import train_val_split
from torch.utils.data import DataLoader
from torch.utils.data.sampler import SubsetRandomSampler
from torch.optim import Adam
from torch.optim import lr_scheduler

def to_np(t):
    return t.cpu().detach().numpy()

def str2bool(v):
    return v.lower() in ("yes", "true", "t", "1")

def save_model(dir_name, model, idx):
    print("MalCNNmodel_{}.model".format(idx))
    save_state_path = os.path.join(dir_name, 'MalCNNmodel_'+ idx +'_dict.pkl')
    torch.save(model.state_dict(), save_state_path)
    print("Chekcpoint saved")

def load_model(dict_name, model, idx):
    save_state_path = os.path.join(dict_name, 'MalCNNmodel_'+ idx +'_dict.pkl')
    state = torch.load(save_state_path)
    model.load_state_dict(state)
    print("Chekcpoint Loaded")

def valid(model,valid_loader,device):
    model.eval()
    total_loss = 0.0
    for batch_idx, (image, tags) in enumerate(valid_loader):
        image = image.to(device)
        tags = tags.to(device)
        outputs = model(image)

        loss_func = nn.CrossEntropyLoss()
        loss = loss_func(outputs, torch.argmax(tags, dim=1))
        total_loss += loss.item()
    logloss = total_loss / len(valid_loader)
    print('Valiadation set Logloss {:2.4f}'.format(logloss))
    return logloss


parser = argparse.ArgumentParser(description='TextCNN Malware Detection With Pytorch')

train_set = parser.add_mutually_exclusive_group()
parser.add_argument('--dataset', default='../train', type=str,
                    help='Dataset root directory path')
parser.add_argument('--label_file', default='../train/train.csv', type=str,
                    help='Specify Label Data path')
parser.add_argument('--use_model_weights', default=False, type=str2bool,
                    help='Use Pretrained model')
parser.add_argument('--pretrained_weights', default=None, type=str,
                    help='Pretrained model Idx')
parser.add_argument('--model_save_dir',default='model/tcnn_weights', type=str,
                    help='Trained Model State Dict Saved Path')
parser.add_argument('--epochs', default=30, type=int,
                    help='Number of epoch for training')
parser.add_argument('--batch_size', default=256, type=int,
                    help='Batch size for training')
parser.add_argument('--num_workers', default=0, type=int,
                    help='Number of workers used in dataloading')
parser.add_argument('--cuda', default=True, type=str2bool,
                    help='Use CUDA to train model')
parser.add_argument('--num_of_class', default=10, type=int,
                    help='Number of classes to predict')
parser.add_argument('--input_len', default=4096, type=int,
                    help='Length of Input for bytes file')
parser.add_argument('--window', default=32, type=int,
                    help='Window size of Dilated CNN')
parser.add_argument('--lr', '--learning-rate', default=1e-3, type=float,
                    help='initial learning rate')
parser.add_argument('--momentum', default=0.9, type=float,
                    help='Momentum value for optim')
parser.add_argument('--weight_decay', default=1e-4, type=float,
                    help='Weight decay for SGD')
parser.add_argument('--gamma', default=0.8, type=float,
                    help='Gamma update if use SGD as optimizer')
parser.add_argument('--log_interval', default=5, type=int,
                    help='Check model training for each k steps')
parser.add_argument('--mode', default='train',
                    help='Choose Train or Eval mode')
parser.add_argument('--do_eval', default=True, type=str2bool,
                    help='Whether to do evaluation on validation set')

args = parser.parse_args()

if torch.cuda.is_available():
    if args.cuda:
        torch.set_default_tensor_type('torch.cuda.FloatTensor')
    if not args.cuda:
        print("WARNING: It looks like you have a CUDA device, but aren't " +
              "using CUDA.\n Run with --cuda for optimal training speed.")
        torch.set_default_tensor_type('torch.FloatTensor')
else:
    torch.set_default_tensor_type('torch.FloatTensor')

clf = Malware_tcnn_classifier(args.dataset, args.label_file, args.input_len, args.batch_size, args.num_workers, args.epochs,
                              args.model_save_dir, args.num_of_class, args.window):


SEED = 42
NFOLDS = 5
kf = KFold(ntrain, n_folds= NFOLDS, random_state=SEED)

def get_oof(clf, x_train, y_train, x_test):
    oof_train = np.zeros((ntrain,))
    oof_test = np.zeros((ntest,))
    oof_test_skf = np.empty((NFOLDS, ntest))

    for i, (train_index, test_index) in enumerate(kf):
        x_tr = train_index
        x_te = test_index

        clf.fit(train_index)

        oof_train[test_index] = clf.predict_proba(dataset, label_file, valid_indices)[:,1]
        oof_test_skf[i, :] = clf.predict_proba(dataset, label_file, None)[:,1]

    oof_test[:] = oof_test_skf.mean(axis=0)
    return oof_train, oof_test






